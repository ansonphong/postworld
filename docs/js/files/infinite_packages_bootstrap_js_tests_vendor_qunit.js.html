<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>infinite/packages/bootstrap/js/tests/vendor/qunit.js - Postworld</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="Postworld" src="../assets/css/logo.png" style="max-height: 65%;" title="Postworld">
            Postworld
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.9</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/loadPost", "classes/pwPostShareReport", "modules/Directives", "modules/Postworld", "modules/Services"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/loadPost.html">loadPost</a></li>
	                            <li><a href="../classes/pwPostShareReport.html">pwPostShareReport</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                            <li><a href="../modules/Directives.html">Directives</a></li>
	                            <li><a href="../modules/Postworld.html">Postworld</a></li>
	                            <li><a href="../modules/Services.html">Services</a></li>
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
                            <h1>infinite/packages/bootstrap/js/tests/vendor/qunit.js <small>File</small></h1>
                        </div>
                        
                        <div class="file">
                            <pre class="prettyprint linenums">
                        /**
                         * QUnit - A JavaScript Unit Testing Framework
                         *
                         * http://docs.jquery.com/QUnit
                         *
                         * Copyright (c) 2012 John Resig, Jörn Zaefferer
                         * Dual licensed under the MIT (MIT-LICENSE.txt)
                         * or GPL (GPL-LICENSE.txt) licenses.
                         */
                        
                        (function(window) {
                        
                        var defined = {
                        	setTimeout: typeof window.setTimeout !== &quot;undefined&quot;,
                        	sessionStorage: (function() {
                        		try {
                        			return !!sessionStorage.getItem;
                        		} catch(e) {
                        			return false;
                        		}
                        	})()
                        };
                        
                        var testId = 0;
                        
                        var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
                        	this.name = name;
                        	this.testName = testName;
                        	this.expected = expected;
                        	this.testEnvironmentArg = testEnvironmentArg;
                        	this.async = async;
                        	this.callback = callback;
                        	this.assertions = [];
                        };
                        Test.prototype = {
                        	init: function() {
                        		var tests = id(&quot;qunit-tests&quot;);
                        		if (tests) {
                        			var b = document.createElement(&quot;strong&quot;);
                        				b.innerHTML = &quot;Running &quot; + this.name;
                        			var li = document.createElement(&quot;li&quot;);
                        				li.appendChild( b );
                        				li.className = &quot;running&quot;;
                        				li.id = this.id = &quot;test-output&quot; + testId++;
                        			tests.appendChild( li );
                        		}
                        	},
                        	setup: function() {
                        		if (this.module != config.previousModule) {
                        			if ( config.previousModule ) {
                        				QUnit.moduleDone( {
                        					name: config.previousModule,
                        					failed: config.moduleStats.bad,
                        					passed: config.moduleStats.all - config.moduleStats.bad,
                        					total: config.moduleStats.all
                        				} );
                        			}
                        			config.previousModule = this.module;
                        			config.moduleStats = { all: 0, bad: 0 };
                        			QUnit.moduleStart( {
                        				name: this.module
                        			} );
                        		}
                        
                        		config.current = this;
                        		this.testEnvironment = extend({
                        			setup: function() {},
                        			teardown: function() {}
                        		}, this.moduleTestEnvironment);
                        		if (this.testEnvironmentArg) {
                        			extend(this.testEnvironment, this.testEnvironmentArg);
                        		}
                        
                        		QUnit.testStart( {
                        			name: this.testName
                        		} );
                        
                        		// allow utility functions to access the current test environment
                        		// TODO why??
                        		QUnit.current_testEnvironment = this.testEnvironment;
                        
                        		try {
                        			if ( !config.pollution ) {
                        				saveGlobal();
                        			}
                        
                        			this.testEnvironment.setup.call(this.testEnvironment);
                        		} catch(e) {
                        			QUnit.ok( false, &quot;Setup failed on &quot; + this.testName + &quot;: &quot; + e.message );
                        		}
                        	},
                        	run: function() {
                        		if ( this.async ) {
                        			QUnit.stop();
                        		}
                        
                        		if ( config.notrycatch ) {
                        			this.callback.call(this.testEnvironment);
                        			return;
                        		}
                        		try {
                        			this.callback.call(this.testEnvironment);
                        		} catch(e) {
                        			fail(&quot;Test &quot; + this.testName + &quot; died, exception and test follows&quot;, e, this.callback);
                        			QUnit.ok( false, &quot;Died on test #&quot; + (this.assertions.length + 1) + &quot;: &quot; + e.message + &quot; - &quot; + QUnit.jsDump.parse(e) );
                        			// else next test will carry the responsibility
                        			saveGlobal();
                        
                        			// Restart the tests if they&#x27;re blocking
                        			if ( config.blocking ) {
                        				start();
                        			}
                        		}
                        	},
                        	teardown: function() {
                        		try {
                        			this.testEnvironment.teardown.call(this.testEnvironment);
                        			checkPollution();
                        		} catch(e) {
                        			QUnit.ok( false, &quot;Teardown failed on &quot; + this.testName + &quot;: &quot; + e.message );
                        		}
                        	},
                        	finish: function() {
                        		if ( this.expected &amp;&amp; this.expected != this.assertions.length ) {
                        			QUnit.ok( false, &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; + this.assertions.length + &quot; were run&quot; );
                        		}
                        
                        		var good = 0, bad = 0,
                        			tests = id(&quot;qunit-tests&quot;);
                        
                        		config.stats.all += this.assertions.length;
                        		config.moduleStats.all += this.assertions.length;
                        
                        		if ( tests ) {
                        			var ol = document.createElement(&quot;ol&quot;);
                        
                        			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
                        				var assertion = this.assertions[i];
                        
                        				var li = document.createElement(&quot;li&quot;);
                        				li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
                        				li.innerHTML = assertion.message || (assertion.result ? &quot;okay&quot; : &quot;failed&quot;);
                        				ol.appendChild( li );
                        
                        				if ( assertion.result ) {
                        					good++;
                        				} else {
                        					bad++;
                        					config.stats.bad++;
                        					config.moduleStats.bad++;
                        				}
                        			}
                        
                        			// store result when possible
                        			if ( QUnit.config.reorder &amp;&amp; defined.sessionStorage ) {
                        				if (bad) {
                        					sessionStorage.setItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName, bad);
                        				} else {
                        					sessionStorage.removeItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName);
                        				}
                        			}
                        
                        			if (bad == 0) {
                        				ol.style.display = &quot;none&quot;;
                        			}
                        
                        			var b = document.createElement(&quot;strong&quot;);
                        			b.innerHTML = this.name + &quot; &lt;b class=&#x27;counts&#x27;&gt;(&lt;b class=&#x27;failed&#x27;&gt;&quot; + bad + &quot;&lt;/b&gt;, &lt;b class=&#x27;passed&#x27;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; + this.assertions.length + &quot;)&lt;/b&gt;&quot;;
                        
                        			var a = document.createElement(&quot;a&quot;);
                        			a.innerHTML = &quot;Rerun&quot;;
                        			a.href = QUnit.url({ filter: getText([b]).replace(/\([^)]+\)$/, &quot;&quot;).replace(/(^\s*|\s*$)/g, &quot;&quot;) });
                        
                        			addEvent(b, &quot;click&quot;, function() {
                        				var next = b.nextSibling.nextSibling,
                        					display = next.style.display;
                        				next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
                        			});
                        
                        			addEvent(b, &quot;dblclick&quot;, function(e) {
                        				var target = e &amp;&amp; e.target ? e.target : window.event.srcElement;
                        				if ( target.nodeName.toLowerCase() == &quot;span&quot; || target.nodeName.toLowerCase() == &quot;b&quot; ) {
                        					target = target.parentNode;
                        				}
                        				if ( window.location &amp;&amp; target.nodeName.toLowerCase() === &quot;strong&quot; ) {
                        					window.location = QUnit.url({ filter: getText([target]).replace(/\([^)]+\)$/, &quot;&quot;).replace(/(^\s*|\s*$)/g, &quot;&quot;) });
                        				}
                        			});
                        
                        			var li = id(this.id);
                        			li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
                        			li.removeChild( li.firstChild );
                        			li.appendChild( b );
                        			li.appendChild( a );
                        			li.appendChild( ol );
                        
                        		} else {
                        			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
                        				if ( !this.assertions[i].result ) {
                        					bad++;
                        					config.stats.bad++;
                        					config.moduleStats.bad++;
                        				}
                        			}
                        		}
                        
                        		try {
                        			QUnit.reset();
                        		} catch(e) {
                        			fail(&quot;reset() failed, following Test &quot; + this.testName + &quot;, exception and reset fn follows&quot;, e, QUnit.reset);
                        		}
                        
                        		QUnit.testDone( {
                        			name: this.testName,
                        			failed: bad,
                        			passed: this.assertions.length - bad,
                        			total: this.assertions.length
                        		} );
                        	},
                        
                        	queue: function() {
                        		var test = this;
                        		synchronize(function() {
                        			test.init();
                        		});
                        		function run() {
                        			// each of these can by async
                        			synchronize(function() {
                        				test.setup();
                        			});
                        			synchronize(function() {
                        				test.run();
                        			});
                        			synchronize(function() {
                        				test.teardown();
                        			});
                        			synchronize(function() {
                        				test.finish();
                        			});
                        		}
                        		// defer when previous test run passed, if storage is available
                        		var bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; +sessionStorage.getItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName);
                        		if (bad) {
                        			run();
                        		} else {
                        			synchronize(run);
                        		};
                        	}
                        
                        };
                        
                        var QUnit = {
                        
                        	// call on start of module test to prepend name to all tests
                        	module: function(name, testEnvironment) {
                        		config.currentModule = name;
                        		config.currentModuleTestEnviroment = testEnvironment;
                        	},
                        
                        	asyncTest: function(testName, expected, callback) {
                        		if ( arguments.length === 2 ) {
                        			callback = expected;
                        			expected = 0;
                        		}
                        
                        		QUnit.test(testName, expected, callback, true);
                        	},
                        
                        	test: function(testName, expected, callback, async) {
                        		var name = &#x27;&lt;span class=&quot;test-name&quot;&gt;&#x27; + testName + &#x27;&lt;/span&gt;&#x27;, testEnvironmentArg;
                        
                        		if ( arguments.length === 2 ) {
                        			callback = expected;
                        			expected = null;
                        		}
                        		// is 2nd argument a testEnvironment?
                        		if ( expected &amp;&amp; typeof expected === &#x27;object&#x27;) {
                        			testEnvironmentArg = expected;
                        			expected = null;
                        		}
                        
                        		if ( config.currentModule ) {
                        			name = &#x27;&lt;span class=&quot;module-name&quot;&gt;&#x27; + config.currentModule + &quot;&lt;/span&gt;: &quot; + name;
                        		}
                        
                        		if ( !validTest(config.currentModule + &quot;: &quot; + testName) ) {
                        			return;
                        		}
                        
                        		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
                        		test.module = config.currentModule;
                        		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
                        		test.queue();
                        	},
                        
                        	/**
                        	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#x27;t slip through.
                        	 */
                        	expect: function(asserts) {
                        		config.current.expected = asserts;
                        	},
                        
                        	/**
                        	 * Asserts true.
                        	 * @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
                        	 */
                        	ok: function(a, msg) {
                        		a = !!a;
                        		var details = {
                        			result: a,
                        			message: msg
                        		};
                        		msg = escapeHtml(msg);
                        		QUnit.log(details);
                        		config.current.assertions.push({
                        			result: a,
                        			message: msg
                        		});
                        	},
                        
                        	/**
                        	 * Checks that the first two arguments are equal, with an optional message.
                        	 * Prints out both actual and expected values.
                        	 *
                        	 * Prefered to ok( actual == expected, message )
                        	 *
                        	 * @example equal( format(&quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
                        	 *
                        	 * @param Object actual
                        	 * @param Object expected
                        	 * @param String message (optional)
                        	 */
                        	equal: function(actual, expected, message) {
                        		QUnit.push(expected == actual, actual, expected, message);
                        	},
                        
                        	notEqual: function(actual, expected, message) {
                        		QUnit.push(expected != actual, actual, expected, message);
                        	},
                        
                        	deepEqual: function(actual, expected, message) {
                        		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
                        	},
                        
                        	notDeepEqual: function(actual, expected, message) {
                        		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
                        	},
                        
                        	strictEqual: function(actual, expected, message) {
                        		QUnit.push(expected === actual, actual, expected, message);
                        	},
                        
                        	notStrictEqual: function(actual, expected, message) {
                        		QUnit.push(expected !== actual, actual, expected, message);
                        	},
                        
                        	raises: function(block, expected, message) {
                        		var actual, ok = false;
                        
                        		if (typeof expected === &#x27;string&#x27;) {
                        			message = expected;
                        			expected = null;
                        		}
                        
                        		try {
                        			block();
                        		} catch (e) {
                        			actual = e;
                        		}
                        
                        		if (actual) {
                        			// we don&#x27;t want to validate thrown error
                        			if (!expected) {
                        				ok = true;
                        			// expected is a regexp
                        			} else if (QUnit.objectType(expected) === &quot;regexp&quot;) {
                        				ok = expected.test(actual);
                        			// expected is a constructor
                        			} else if (actual instanceof expected) {
                        				ok = true;
                        			// expected is a validation function which returns true is validation passed
                        			} else if (expected.call({}, actual) === true) {
                        				ok = true;
                        			}
                        		}
                        
                        		QUnit.ok(ok, message);
                        	},
                        
                        	start: function() {
                        		config.semaphore--;
                        		if (config.semaphore &gt; 0) {
                        			// don&#x27;t start until equal number of stop-calls
                        			return;
                        		}
                        		if (config.semaphore &lt; 0) {
                        			// ignore if start is called more often then stop
                        			config.semaphore = 0;
                        		}
                        		// A slight delay, to avoid any current callbacks
                        		if ( defined.setTimeout ) {
                        			window.setTimeout(function() {
                        				if (config.semaphore &gt; 0) {
                        					return;
                        				}
                        				if ( config.timeout ) {
                        					clearTimeout(config.timeout);
                        				}
                        
                        				config.blocking = false;
                        				process();
                        			}, 13);
                        		} else {
                        			config.blocking = false;
                        			process();
                        		}
                        	},
                        
                        	stop: function(timeout) {
                        		config.semaphore++;
                        		config.blocking = true;
                        
                        		if ( timeout &amp;&amp; defined.setTimeout ) {
                        			clearTimeout(config.timeout);
                        			config.timeout = window.setTimeout(function() {
                        				QUnit.ok( false, &quot;Test timed out&quot; );
                        				QUnit.start();
                        			}, timeout);
                        		}
                        	}
                        };
                        
                        // Backwards compatibility, deprecated
                        QUnit.equals = QUnit.equal;
                        QUnit.same = QUnit.deepEqual;
                        
                        // Maintain internal state
                        var config = {
                        	// The queue of tests to run
                        	queue: [],
                        
                        	// block until document ready
                        	blocking: true,
                        
                        	// when enabled, show only failing tests
                        	// gets persisted through sessionStorage and can be changed in UI via checkbox
                        	hidepassed: false,
                        
                        	// by default, run previously failed tests first
                        	// very useful in combination with &quot;Hide passed tests&quot; checked
                        	reorder: true,
                        
                        	// by default, modify document.title when suite is done
                        	altertitle: true,
                        
                        	urlConfig: [&#x27;noglobals&#x27;, &#x27;notrycatch&#x27;]
                        };
                        
                        // Load paramaters
                        (function() {
                        	var location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
                        		params = location.search.slice( 1 ).split( &quot;&amp;&quot; ),
                        		length = params.length,
                        		urlParams = {},
                        		current;
                        
                        	if ( params[ 0 ] ) {
                        		for ( var i = 0; i &lt; length; i++ ) {
                        			current = params[ i ].split( &quot;=&quot; );
                        			current[ 0 ] = decodeURIComponent( current[ 0 ] );
                        			// allow just a key to turn on a flag, e.g., test.html?noglobals
                        			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
                        			urlParams[ current[ 0 ] ] = current[ 1 ];
                        		}
                        	}
                        
                        	QUnit.urlParams = urlParams;
                        	config.filter = urlParams.filter;
                        
                        	// Figure out if we&#x27;re running the tests from a server or not
                        	QUnit.isLocal = !!(location.protocol === &#x27;file:&#x27;);
                        })();
                        
                        // Expose the API as global variables, unless an &#x27;exports&#x27;
                        // object exists, in that case we assume we&#x27;re in CommonJS
                        if ( typeof exports === &quot;undefined&quot; || typeof require === &quot;undefined&quot; ) {
                        	extend(window, QUnit);
                        	window.QUnit = QUnit;
                        } else {
                        	extend(exports, QUnit);
                        	exports.QUnit = QUnit;
                        }
                        
                        // define these after exposing globals to keep them in these QUnit namespace only
                        extend(QUnit, {
                        	config: config,
                        
                        	// Initialize the configuration options
                        	init: function() {
                        		extend(config, {
                        			stats: { all: 0, bad: 0 },
                        			moduleStats: { all: 0, bad: 0 },
                        			started: +new Date,
                        			updateRate: 1000,
                        			blocking: false,
                        			autostart: true,
                        			autorun: false,
                        			filter: &quot;&quot;,
                        			queue: [],
                        			semaphore: 0
                        		});
                        
                        		var tests = id( &quot;qunit-tests&quot; ),
                        			banner = id( &quot;qunit-banner&quot; ),
                        			result = id( &quot;qunit-testresult&quot; );
                        
                        		if ( tests ) {
                        			tests.innerHTML = &quot;&quot;;
                        		}
                        
                        		if ( banner ) {
                        			banner.className = &quot;&quot;;
                        		}
                        
                        		if ( result ) {
                        			result.parentNode.removeChild( result );
                        		}
                        
                        		if ( tests ) {
                        			result = document.createElement( &quot;p&quot; );
                        			result.id = &quot;qunit-testresult&quot;;
                        			result.className = &quot;result&quot;;
                        			tests.parentNode.insertBefore( result, tests );
                        			result.innerHTML = &#x27;Running...&lt;br/&gt;&amp;nbsp;&#x27;;
                        		}
                        	},
                        
                        	/**
                        	 * Resets the test setup. Useful for tests that modify the DOM.
                        	 *
                        	 * If jQuery is available, uses jQuery&#x27;s html(), otherwise just innerHTML.
                        	 */
                        	reset: function() {
                        		if ( window.jQuery ) {
                        			jQuery( &quot;#qunit-fixture&quot; ).html( config.fixture );
                        		} else {
                        			var main = id( &#x27;qunit-fixture&#x27; );
                        			if ( main ) {
                        				main.innerHTML = config.fixture;
                        			}
                        		}
                        	},
                        
                        	/**
                        	 * Trigger an event on an element.
                        	 *
                        	 * @example triggerEvent( document.body, &quot;click&quot; );
                        	 *
                        	 * @param DOMElement elem
                        	 * @param String type
                        	 */
                        	triggerEvent: function( elem, type, event ) {
                        		if ( document.createEvent ) {
                        			event = document.createEvent(&quot;MouseEvents&quot;);
                        			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
                        				0, 0, 0, 0, 0, false, false, false, false, 0, null);
                        			elem.dispatchEvent( event );
                        
                        		} else if ( elem.fireEvent ) {
                        			elem.fireEvent(&quot;on&quot;+type);
                        		}
                        	},
                        
                        	// Safe object type checking
                        	is: function( type, obj ) {
                        		return QUnit.objectType( obj ) == type;
                        	},
                        
                        	objectType: function( obj ) {
                        		if (typeof obj === &quot;undefined&quot;) {
                        				return &quot;undefined&quot;;
                        
                        		// consider: typeof null === object
                        		}
                        		if (obj === null) {
                        				return &quot;null&quot;;
                        		}
                        
                        		var type = Object.prototype.toString.call( obj )
                        			.match(/^\[object\s(.*)\]$/)[1] || &#x27;&#x27;;
                        
                        		switch (type) {
                        				case &#x27;Number&#x27;:
                        						if (isNaN(obj)) {
                        								return &quot;nan&quot;;
                        						} else {
                        								return &quot;number&quot;;
                        						}
                        				case &#x27;String&#x27;:
                        				case &#x27;Boolean&#x27;:
                        				case &#x27;Array&#x27;:
                        				case &#x27;Date&#x27;:
                        				case &#x27;RegExp&#x27;:
                        				case &#x27;Function&#x27;:
                        						return type.toLowerCase();
                        		}
                        		if (typeof obj === &quot;object&quot;) {
                        				return &quot;object&quot;;
                        		}
                        		return undefined;
                        	},
                        
                        	push: function(result, actual, expected, message) {
                        		var details = {
                        			result: result,
                        			message: message,
                        			actual: actual,
                        			expected: expected
                        		};
                        
                        		message = escapeHtml(message) || (result ? &quot;okay&quot; : &quot;failed&quot;);
                        		message = &#x27;&lt;span class=&quot;test-message&quot;&gt;&#x27; + message + &quot;&lt;/span&gt;&quot;;
                        		expected = escapeHtml(QUnit.jsDump.parse(expected));
                        		actual = escapeHtml(QUnit.jsDump.parse(actual));
                        		var output = message + &#x27;&lt;table&gt;&lt;tr class=&quot;test-expected&quot;&gt;&lt;th&gt;Expected: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + expected + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
                        		if (actual != expected) {
                        			output += &#x27;&lt;tr class=&quot;test-actual&quot;&gt;&lt;th&gt;Result: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + actual + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
                        			output += &#x27;&lt;tr class=&quot;test-diff&quot;&gt;&lt;th&gt;Diff: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + QUnit.diff(expected, actual) +&#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
                        		}
                        		if (!result) {
                        			var source = sourceFromStacktrace();
                        			if (source) {
                        				details.source = source;
                        				output += &#x27;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + escapeHtml(source) + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
                        			}
                        		}
                        		output += &quot;&lt;/table&gt;&quot;;
                        
                        		QUnit.log(details);
                        
                        		config.current.assertions.push({
                        			result: !!result,
                        			message: output
                        		});
                        	},
                        
                        	url: function( params ) {
                        		params = extend( extend( {}, QUnit.urlParams ), params );
                        		var querystring = &quot;?&quot;,
                        			key;
                        		for ( key in params ) {
                        			querystring += encodeURIComponent( key ) + &quot;=&quot; +
                        				encodeURIComponent( params[ key ] ) + &quot;&amp;&quot;;
                        		}
                        		return window.location.pathname + querystring.slice( 0, -1 );
                        	},
                        
                        	extend: extend,
                        	id: id,
                        	addEvent: addEvent,
                        
                        	// Logging callbacks; all receive a single argument with the listed properties
                        	// run test/logs.html for any related changes
                        	begin: function() {},
                        	// done: { failed, passed, total, runtime }
                        	done: function() {},
                        	// log: { result, actual, expected, message }
                        	log: function() {},
                        	// testStart: { name }
                        	testStart: function() {},
                        	// testDone: { name, failed, passed, total }
                        	testDone: function() {},
                        	// moduleStart: { name }
                        	moduleStart: function() {},
                        	// moduleDone: { name, failed, passed, total }
                        	moduleDone: function() {}
                        });
                        
                        if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
                        	config.autorun = true;
                        }
                        
                        QUnit.load = function() {
                        	QUnit.begin({});
                        
                        	// Initialize the config, saving the execution queue
                        	var oldconfig = extend({}, config);
                        	QUnit.init();
                        	extend(config, oldconfig);
                        
                        	config.blocking = false;
                        
                        	var urlConfigHtml = &#x27;&#x27;, len = config.urlConfig.length;
                        	for ( var i = 0, val; i &lt; len, val = config.urlConfig[i]; i++ ) {
                        		config[val] = QUnit.urlParams[val];
                        		urlConfigHtml += &#x27;&lt;label&gt;&lt;input name=&quot;&#x27; + val + &#x27;&quot; type=&quot;checkbox&quot;&#x27; + ( config[val] ? &#x27; checked=&quot;checked&quot;&#x27; : &#x27;&#x27; ) + &#x27;&gt;&#x27; + val + &#x27;&lt;/label&gt;&#x27;;
                        	}
                        
                        	var userAgent = id(&quot;qunit-userAgent&quot;);
                        	if ( userAgent ) {
                        		userAgent.innerHTML = navigator.userAgent;
                        	}
                        	var banner = id(&quot;qunit-header&quot;);
                        	if ( banner ) {
                        		banner.innerHTML = &#x27;&lt;a href=&quot;&#x27; + QUnit.url({ filter: undefined }) + &#x27;&quot;&gt; &#x27; + banner.innerHTML + &#x27;&lt;/a&gt; &#x27; + urlConfigHtml;
                        		addEvent( banner, &quot;change&quot;, function( event ) {
                        			var params = {};
                        			params[ event.target.name ] = event.target.checked ? true : undefined;
                        			window.location = QUnit.url( params );
                        		});
                        	}
                        
                        	var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
                        	if ( toolbar ) {
                        		var filter = document.createElement(&quot;input&quot;);
                        		filter.type = &quot;checkbox&quot;;
                        		filter.id = &quot;qunit-filter-pass&quot;;
                        		addEvent( filter, &quot;click&quot;, function() {
                        			var ol = document.getElementById(&quot;qunit-tests&quot;);
                        			if ( filter.checked ) {
                        				ol.className = ol.className + &quot; hidepass&quot;;
                        			} else {
                        				var tmp = &quot; &quot; + ol.className.replace( /[\n\t\r]/g, &quot; &quot; ) + &quot; &quot;;
                        				ol.className = tmp.replace(/ hidepass /, &quot; &quot;);
                        			}
                        			if ( defined.sessionStorage ) {
                        				if (filter.checked) {
                        					sessionStorage.setItem(&quot;qunit-filter-passed-tests&quot;, &quot;true&quot;);
                        				} else {
                        					sessionStorage.removeItem(&quot;qunit-filter-passed-tests&quot;);
                        				}
                        			}
                        		});
                        		if ( config.hidepassed || defined.sessionStorage &amp;&amp; sessionStorage.getItem(&quot;qunit-filter-passed-tests&quot;) ) {
                        			filter.checked = true;
                        			var ol = document.getElementById(&quot;qunit-tests&quot;);
                        			ol.className = ol.className + &quot; hidepass&quot;;
                        		}
                        		toolbar.appendChild( filter );
                        
                        		var label = document.createElement(&quot;label&quot;);
                        		label.setAttribute(&quot;for&quot;, &quot;qunit-filter-pass&quot;);
                        		label.innerHTML = &quot;Hide passed tests&quot;;
                        		toolbar.appendChild( label );
                        	}
                        
                        	var main = id(&#x27;qunit-fixture&#x27;);
                        	if ( main ) {
                        		config.fixture = main.innerHTML;
                        	}
                        
                        	if (config.autostart) {
                        		QUnit.start();
                        	}
                        };
                        
                        addEvent(window, &quot;load&quot;, QUnit.load);
                        
                        function done() {
                        	config.autorun = true;
                        
                        	// Log the last module results
                        	if ( config.currentModule ) {
                        		QUnit.moduleDone( {
                        			name: config.currentModule,
                        			failed: config.moduleStats.bad,
                        			passed: config.moduleStats.all - config.moduleStats.bad,
                        			total: config.moduleStats.all
                        		} );
                        	}
                        
                        	var banner = id(&quot;qunit-banner&quot;),
                        		tests = id(&quot;qunit-tests&quot;),
                        		runtime = +new Date - config.started,
                        		passed = config.stats.all - config.stats.bad,
                        		html = [
                        			&#x27;Tests completed in &#x27;,
                        			runtime,
                        			&#x27; milliseconds.&lt;br/&gt;&#x27;,
                        			&#x27;&lt;span class=&quot;passed&quot;&gt;&#x27;,
                        			passed,
                        			&#x27;&lt;/span&gt; tests of &lt;span class=&quot;total&quot;&gt;&#x27;,
                        			config.stats.all,
                        			&#x27;&lt;/span&gt; passed, &lt;span class=&quot;failed&quot;&gt;&#x27;,
                        			config.stats.bad,
                        			&#x27;&lt;/span&gt; failed.&#x27;
                        		].join(&#x27;&#x27;);
                        
                        	if ( banner ) {
                        		banner.className = (config.stats.bad ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;);
                        	}
                        
                        	if ( tests ) {
                        		id( &quot;qunit-testresult&quot; ).innerHTML = html;
                        	}
                        
                        	if ( config.altertitle &amp;&amp; typeof document !== &quot;undefined&quot; &amp;&amp; document.title ) {
                        		// show ✖ for good, ✔ for bad suite result in title
                        		// use escape sequences in case file gets loaded with non-utf-8-charset
                        		document.title = [
                        			(config.stats.bad ? &quot;\u2716&quot; : &quot;\u2714&quot;),
                        			document.title.replace(/^[\u2714\u2716] /i, &quot;&quot;)
                        		].join(&quot; &quot;);
                        	}
                        
                        	QUnit.done( {
                        		failed: config.stats.bad,
                        		passed: passed,
                        		total: config.stats.all,
                        		runtime: runtime
                        	} );
                        }
                        
                        function validTest( name ) {
                        	var filter = config.filter,
                        		run = false;
                        
                        	if ( !filter ) {
                        		return true;
                        	}
                        
                        	var not = filter.charAt( 0 ) === &quot;!&quot;;
                        	if ( not ) {
                        		filter = filter.slice( 1 );
                        	}
                        
                        	if ( name.indexOf( filter ) !== -1 ) {
                        		return !not;
                        	}
                        
                        	if ( not ) {
                        		run = true;
                        	}
                        
                        	return run;
                        }
                        
                        // so far supports only Firefox, Chrome and Opera (buggy)
                        // could be extended in the future to use something like https://github.com/csnover/TraceKit
                        function sourceFromStacktrace() {
                        	try {
                        		throw new Error();
                        	} catch ( e ) {
                        		if (e.stacktrace) {
                        			// Opera
                        			return e.stacktrace.split(&quot;\n&quot;)[6];
                        		} else if (e.stack) {
                        			// Firefox, Chrome
                        			return e.stack.split(&quot;\n&quot;)[4];
                        		} else if (e.sourceURL) {
                        			// Safari, PhantomJS
                        			// TODO sourceURL points at the &#x27;throw new Error&#x27; line above, useless
                        			//return e.sourceURL + &quot;:&quot; + e.line;
                        		}
                        	}
                        }
                        
                        function escapeHtml(s) {
                        	if (!s) {
                        		return &quot;&quot;;
                        	}
                        	s = s + &quot;&quot;;
                        	return s.replace(/[\&amp;&quot;&lt;&gt;\\]/g, function(s) {
                        		switch(s) {
                        			case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;;
                        			case &quot;\\&quot;: return &quot;\\\\&quot;;
                        			case &#x27;&quot;&#x27;: return &#x27;\&quot;&#x27;;
                        			case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;;
                        			case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;;
                        			default: return s;
                        		}
                        	});
                        }
                        
                        function synchronize( callback ) {
                        	config.queue.push( callback );
                        
                        	if ( config.autorun &amp;&amp; !config.blocking ) {
                        		process();
                        	}
                        }
                        
                        function process() {
                        	var start = (new Date()).getTime();
                        
                        	while ( config.queue.length &amp;&amp; !config.blocking ) {
                        		if ( config.updateRate &lt;= 0 || (((new Date()).getTime() - start) &lt; config.updateRate) ) {
                        			config.queue.shift()();
                        		} else {
                        			window.setTimeout( process, 13 );
                        			break;
                        		}
                        	}
                        	if (!config.blocking &amp;&amp; !config.queue.length) {
                        		done();
                        	}
                        }
                        
                        function saveGlobal() {
                        	config.pollution = [];
                        
                        	if ( config.noglobals ) {
                        		for ( var key in window ) {
                        			config.pollution.push( key );
                        		}
                        	}
                        }
                        
                        function checkPollution( name ) {
                        	var old = config.pollution;
                        	saveGlobal();
                        
                        	var newGlobals = diff( config.pollution, old );
                        	if ( newGlobals.length &gt; 0 ) {
                        		ok( false, &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
                        	}
                        
                        	var deletedGlobals = diff( old, config.pollution );
                        	if ( deletedGlobals.length &gt; 0 ) {
                        		ok( false, &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
                        	}
                        }
                        
                        // returns a new Array with the elements that are in a but not in b
                        function diff( a, b ) {
                        	var result = a.slice();
                        	for ( var i = 0; i &lt; result.length; i++ ) {
                        		for ( var j = 0; j &lt; b.length; j++ ) {
                        			if ( result[i] === b[j] ) {
                        				result.splice(i, 1);
                        				i--;
                        				break;
                        			}
                        		}
                        	}
                        	return result;
                        }
                        
                        function fail(message, exception, callback) {
                        	if ( typeof console !== &quot;undefined&quot; &amp;&amp; console.error &amp;&amp; console.warn ) {
                        		console.error(message);
                        		console.error(exception);
                        		console.warn(callback.toString());
                        
                        	} else if ( window.opera &amp;&amp; opera.postError ) {
                        		opera.postError(message, exception, callback.toString);
                        	}
                        }
                        
                        function extend(a, b) {
                        	for ( var prop in b ) {
                        		if ( b[prop] === undefined ) {
                        			delete a[prop];
                        		} else {
                        			a[prop] = b[prop];
                        		}
                        	}
                        
                        	return a;
                        }
                        
                        function addEvent(elem, type, fn) {
                        	if ( elem.addEventListener ) {
                        		elem.addEventListener( type, fn, false );
                        	} else if ( elem.attachEvent ) {
                        		elem.attachEvent( &quot;on&quot; + type, fn );
                        	} else {
                        		fn();
                        	}
                        }
                        
                        function id(name) {
                        	return !!(typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById) &amp;&amp;
                        		document.getElementById( name );
                        }
                        
                        // Test for equality any JavaScript type.
                        // Discussions and reference: http://philrathe.com/articles/equiv
                        // Test suites: http://philrathe.com/tests/equiv
                        // Author: Philippe Rathé &lt;prathe@gmail.com&gt;
                        QUnit.equiv = function () {
                        
                        	var innerEquiv; // the real equiv function
                        	var callers = []; // stack to decide between skip/abort functions
                        	var parents = []; // stack to avoiding loops from circular referencing
                        
                        	// Call the o related callback with the given arguments.
                        	function bindCallbacks(o, callbacks, args) {
                        		var prop = QUnit.objectType(o);
                        		if (prop) {
                        			if (QUnit.objectType(callbacks[prop]) === &quot;function&quot;) {
                        				return callbacks[prop].apply(callbacks, args);
                        			} else {
                        				return callbacks[prop]; // or undefined
                        			}
                        		}
                        	}
                        
                        	var callbacks = function () {
                        
                        		// for string, boolean, number and null
                        		function useStrictEquality(b, a) {
                        			if (b instanceof a.constructor || a instanceof b.constructor) {
                        				// to catch short annotaion VS &#x27;new&#x27; annotation of a
                        				// declaration
                        				// e.g. var i = 1;
                        				// var j = new Number(1);
                        				return a == b;
                        			} else {
                        				return a === b;
                        			}
                        		}
                        
                        		return {
                        			&quot;string&quot; : useStrictEquality,
                        			&quot;boolean&quot; : useStrictEquality,
                        			&quot;number&quot; : useStrictEquality,
                        			&quot;null&quot; : useStrictEquality,
                        			&quot;undefined&quot; : useStrictEquality,
                        
                        			&quot;nan&quot; : function(b) {
                        				return isNaN(b);
                        			},
                        
                        			&quot;date&quot; : function(b, a) {
                        				return QUnit.objectType(b) === &quot;date&quot;
                        						&amp;&amp; a.valueOf() === b.valueOf();
                        			},
                        
                        			&quot;regexp&quot; : function(b, a) {
                        				return QUnit.objectType(b) === &quot;regexp&quot;
                        						&amp;&amp; a.source === b.source &amp;&amp; // the regex itself
                        						a.global === b.global &amp;&amp; // and its modifers
                        													// (gmi) ...
                        						a.ignoreCase === b.ignoreCase
                        						&amp;&amp; a.multiline === b.multiline;
                        			},
                        
                        			// - skip when the property is a method of an instance (OOP)
                        			// - abort otherwise,
                        			// initial === would have catch identical references anyway
                        			&quot;function&quot; : function() {
                        				var caller = callers[callers.length - 1];
                        				return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
                        			},
                        
                        			&quot;array&quot; : function(b, a) {
                        				var i, j, loop;
                        				var len;
                        
                        				// b could be an object literal here
                        				if (!(QUnit.objectType(b) === &quot;array&quot;)) {
                        					return false;
                        				}
                        
                        				len = a.length;
                        				if (len !== b.length) { // safe and faster
                        					return false;
                        				}
                        
                        				// track reference to avoid circular references
                        				parents.push(a);
                        				for (i = 0; i &lt; len; i++) {
                        					loop = false;
                        					for (j = 0; j &lt; parents.length; j++) {
                        						if (parents[j] === a[i]) {
                        							loop = true;// dont rewalk array
                        						}
                        					}
                        					if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
                        						parents.pop();
                        						return false;
                        					}
                        				}
                        				parents.pop();
                        				return true;
                        			},
                        
                        			&quot;object&quot; : function(b, a) {
                        				var i, j, loop;
                        				var eq = true; // unless we can proove it
                        				var aProperties = [], bProperties = []; // collection of
                        														// strings
                        
                        				// comparing constructors is more strict than using
                        				// instanceof
                        				if (a.constructor !== b.constructor) {
                        					return false;
                        				}
                        
                        				// stack constructor before traversing properties
                        				callers.push(a.constructor);
                        				// track reference to avoid circular references
                        				parents.push(a);
                        
                        				for (i in a) { // be strict: don&#x27;t ensures hasOwnProperty
                        								// and go deep
                        					loop = false;
                        					for (j = 0; j &lt; parents.length; j++) {
                        						if (parents[j] === a[i])
                        							loop = true; // don&#x27;t go down the same path
                        											// twice
                        					}
                        					aProperties.push(i); // collect a&#x27;s properties
                        
                        					if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
                        						eq = false;
                        						break;
                        					}
                        				}
                        
                        				callers.pop(); // unstack, we are done
                        				parents.pop();
                        
                        				for (i in b) {
                        					bProperties.push(i); // collect b&#x27;s properties
                        				}
                        
                        				// Ensures identical properties name
                        				return eq
                        						&amp;&amp; innerEquiv(aProperties.sort(), bProperties
                        								.sort());
                        			}
                        		};
                        	}();
                        
                        	innerEquiv = function() { // can take multiple arguments
                        		var args = Array.prototype.slice.apply(arguments);
                        		if (args.length &lt; 2) {
                        			return true; // end transition
                        		}
                        
                        		return (function(a, b) {
                        			if (a === b) {
                        				return true; // catch the most you can
                        			} else if (a === null || b === null || typeof a === &quot;undefined&quot;
                        					|| typeof b === &quot;undefined&quot;
                        					|| QUnit.objectType(a) !== QUnit.objectType(b)) {
                        				return false; // don&#x27;t lose time with error prone cases
                        			} else {
                        				return bindCallbacks(a, callbacks, [ b, a ]);
                        			}
                        
                        			// apply transition with (1..n) arguments
                        		})(args[0], args[1])
                        				&amp;&amp; arguments.callee.apply(this, args.splice(1,
                        						args.length - 1));
                        	};
                        
                        	return innerEquiv;
                        
                        }();
                        
                        /**
                         * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |
                         * http://flesler.blogspot.com Licensed under BSD
                         * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008
                         *
                         * @projectDescription Advanced and extensible data dumping for Javascript.
                         * @version 1.0.0
                         * @author Ariel Flesler
                         * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
                         */
                        QUnit.jsDump = (function() {
                        	function quote( str ) {
                        		return &#x27;&quot;&#x27; + str.toString().replace(/&quot;/g, &#x27;\\&quot;&#x27;) + &#x27;&quot;&#x27;;
                        	};
                        	function literal( o ) {
                        		return o + &#x27;&#x27;;
                        	};
                        	function join( pre, arr, post ) {
                        		var s = jsDump.separator(),
                        			base = jsDump.indent(),
                        			inner = jsDump.indent(1);
                        		if ( arr.join )
                        			arr = arr.join( &#x27;,&#x27; + s + inner );
                        		if ( !arr )
                        			return pre + post;
                        		return [ pre, inner + arr, base + post ].join(s);
                        	};
                        	function array( arr, stack ) {
                        		var i = arr.length, ret = Array(i);
                        		this.up();
                        		while ( i-- )
                        			ret[i] = this.parse( arr[i] , undefined , stack);
                        		this.down();
                        		return join( &#x27;[&#x27;, ret, &#x27;]&#x27; );
                        	};
                        
                        	var reName = /^function (\w+)/;
                        
                        	var jsDump = {
                        		parse:function( obj, type, stack ) { //type is used mostly internally, you can fix a (custom)type in advance
                        			stack = stack || [ ];
                        			var parser = this.parsers[ type || this.typeOf(obj) ];
                        			type = typeof parser;
                        			var inStack = inArray(obj, stack);
                        			if (inStack != -1) {
                        				return &#x27;recursion(&#x27;+(inStack - stack.length)+&#x27;)&#x27;;
                        			}
                        			//else
                        			if (type == &#x27;function&#x27;)  {
                        					stack.push(obj);
                        					var res = parser.call( this, obj, stack );
                        					stack.pop();
                        					return res;
                        			}
                        			// else
                        			return (type == &#x27;string&#x27;) ? parser : this.parsers.error;
                        		},
                        		typeOf:function( obj ) {
                        			var type;
                        			if ( obj === null ) {
                        				type = &quot;null&quot;;
                        			} else if (typeof obj === &quot;undefined&quot;) {
                        				type = &quot;undefined&quot;;
                        			} else if (QUnit.is(&quot;RegExp&quot;, obj)) {
                        				type = &quot;regexp&quot;;
                        			} else if (QUnit.is(&quot;Date&quot;, obj)) {
                        				type = &quot;date&quot;;
                        			} else if (QUnit.is(&quot;Function&quot;, obj)) {
                        				type = &quot;function&quot;;
                        			} else if (typeof obj.setInterval !== undefined &amp;&amp; typeof obj.document !== &quot;undefined&quot; &amp;&amp; typeof obj.nodeType === &quot;undefined&quot;) {
                        				type = &quot;window&quot;;
                        			} else if (obj.nodeType === 9) {
                        				type = &quot;document&quot;;
                        			} else if (obj.nodeType) {
                        				type = &quot;node&quot;;
                        			} else if (typeof obj === &quot;object&quot; &amp;&amp; typeof obj.length === &quot;number&quot; &amp;&amp; obj.length &gt;= 0) {
                        				type = &quot;array&quot;;
                        			} else {
                        				type = typeof obj;
                        			}
                        			return type;
                        		},
                        		separator:function() {
                        			return this.multiline ?	this.HTML ? &#x27;&lt;br /&gt;&#x27; : &#x27;\n&#x27; : this.HTML ? &#x27;&amp;nbsp;&#x27; : &#x27; &#x27;;
                        		},
                        		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
                        			if ( !this.multiline )
                        				return &#x27;&#x27;;
                        			var chr = this.indentChar;
                        			if ( this.HTML )
                        				chr = chr.replace(/\t/g,&#x27;   &#x27;).replace(/ /g,&#x27;&amp;nbsp;&#x27;);
                        			return Array( this._depth_ + (extra||0) ).join(chr);
                        		},
                        		up:function( a ) {
                        			this._depth_ += a || 1;
                        		},
                        		down:function( a ) {
                        			this._depth_ -= a || 1;
                        		},
                        		setParser:function( name, parser ) {
                        			this.parsers[name] = parser;
                        		},
                        		// The next 3 are exposed so you can use them
                        		quote:quote,
                        		literal:literal,
                        		join:join,
                        		//
                        		_depth_: 1,
                        		// This is the list of parsers, to modify them, use jsDump.setParser
                        		parsers:{
                        			window: &#x27;[Window]&#x27;,
                        			document: &#x27;[Document]&#x27;,
                        			error:&#x27;[ERROR]&#x27;, //when no parser is found, shouldn&#x27;t happen
                        			unknown: &#x27;[Unknown]&#x27;,
                        			&#x27;null&#x27;:&#x27;null&#x27;,
                        			&#x27;undefined&#x27;:&#x27;undefined&#x27;,
                        			&#x27;function&#x27;:function( fn ) {
                        				var ret = &#x27;function&#x27;,
                        					name = &#x27;name&#x27; in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
                        				if ( name )
                        					ret += &#x27; &#x27; + name;
                        				ret += &#x27;(&#x27;;
                        
                        				ret = [ ret, QUnit.jsDump.parse( fn, &#x27;functionArgs&#x27; ), &#x27;){&#x27;].join(&#x27;&#x27;);
                        				return join( ret, QUnit.jsDump.parse(fn,&#x27;functionCode&#x27;), &#x27;}&#x27; );
                        			},
                        			array: array,
                        			nodelist: array,
                        			arguments: array,
                        			object:function( map, stack ) {
                        				var ret = [ ];
                        				QUnit.jsDump.up();
                        				for ( var key in map ) {
                        				    var val = map[key];
                        					ret.push( QUnit.jsDump.parse(key,&#x27;key&#x27;) + &#x27;: &#x27; + QUnit.jsDump.parse(val, undefined, stack));
                                        }
                        				QUnit.jsDump.down();
                        				return join( &#x27;{&#x27;, ret, &#x27;}&#x27; );
                        			},
                        			node:function( node ) {
                        				var open = QUnit.jsDump.HTML ? &#x27;&amp;lt;&#x27; : &#x27;&lt;&#x27;,
                        					close = QUnit.jsDump.HTML ? &#x27;&amp;gt;&#x27; : &#x27;&gt;&#x27;;
                        
                        				var tag = node.nodeName.toLowerCase(),
                        					ret = open + tag;
                        
                        				for ( var a in QUnit.jsDump.DOMAttrs ) {
                        					var val = node[QUnit.jsDump.DOMAttrs[a]];
                        					if ( val )
                        						ret += &#x27; &#x27; + a + &#x27;=&#x27; + QUnit.jsDump.parse( val, &#x27;attribute&#x27; );
                        				}
                        				return ret + close + open + &#x27;/&#x27; + tag + close;
                        			},
                        			functionArgs:function( fn ) {//function calls it internally, it&#x27;s the arguments part of the function
                        				var l = fn.length;
                        				if ( !l ) return &#x27;&#x27;;
                        
                        				var args = Array(l);
                        				while ( l-- )
                        					args[l] = String.fromCharCode(97+l);//97 is &#x27;a&#x27;
                        				return &#x27; &#x27; + args.join(&#x27;, &#x27;) + &#x27; &#x27;;
                        			},
                        			key:quote, //object calls it internally, the key part of an item in a map
                        			functionCode:&#x27;[code]&#x27;, //function calls it internally, it&#x27;s the content of the function
                        			attribute:quote, //node calls it internally, it&#x27;s an html attribute value
                        			string:quote,
                        			date:quote,
                        			regexp:literal, //regex
                        			number:literal,
                        			&#x27;boolean&#x27;:literal
                        		},
                        		DOMAttrs:{//attributes to dump from nodes, name=&gt;realName
                        			id:&#x27;id&#x27;,
                        			name:&#x27;name&#x27;,
                        			&#x27;class&#x27;:&#x27;className&#x27;
                        		},
                        		HTML:false,//if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
                        		indentChar:&#x27;  &#x27;,//indentation unit
                        		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
                        	};
                        
                        	return jsDump;
                        })();
                        
                        // from Sizzle.js
                        function getText( elems ) {
                        	var ret = &quot;&quot;, elem;
                        
                        	for ( var i = 0; elems[i]; i++ ) {
                        		elem = elems[i];
                        
                        		// Get the text from text nodes and CDATA nodes
                        		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
                        			ret += elem.nodeValue;
                        
                        		// Traverse everything else, except comment nodes
                        		} else if ( elem.nodeType !== 8 ) {
                        			ret += getText( elem.childNodes );
                        		}
                        	}
                        
                        	return ret;
                        };
                        
                        //from jquery.js
                        function inArray( elem, array ) {
                        	if ( array.indexOf ) {
                        		return array.indexOf( elem );
                        	}
                        
                        	for ( var i = 0, length = array.length; i &lt; length; i++ ) {
                        		if ( array[ i ] === elem ) {
                        			return i;
                        		}
                        	}
                        
                        	return -1;
                        }
                        
                        /*
                         * Javascript Diff Algorithm
                         *  By John Resig (http://ejohn.org/)
                         *  Modified by Chu Alan &quot;sprite&quot;
                         *
                         * Released under the MIT license.
                         *
                         * More Info:
                         *  http://ejohn.org/projects/javascript-diff-algorithm/
                         *
                         * Usage: QUnit.diff(expected, actual)
                         *
                         * QUnit.diff(&quot;the quick brown fox jumped over&quot;, &quot;the quick fox jumps over&quot;) == &quot;the  quick &lt;del&gt;brown &lt;/del&gt; fox &lt;del&gt;jumped &lt;/del&gt;&lt;ins&gt;jumps &lt;/ins&gt; over&quot;
                         */
                        QUnit.diff = (function() {
                        	function diff(o, n) {
                        		var ns = {};
                        		var os = {};
                        
                        		for (var i = 0; i &lt; n.length; i++) {
                        			if (ns[n[i]] == null)
                        				ns[n[i]] = {
                        					rows: [],
                        					o: null
                        				};
                        			ns[n[i]].rows.push(i);
                        		}
                        
                        		for (var i = 0; i &lt; o.length; i++) {
                        			if (os[o[i]] == null)
                        				os[o[i]] = {
                        					rows: [],
                        					n: null
                        				};
                        			os[o[i]].rows.push(i);
                        		}
                        
                        		for (var i in ns) {
                        			if (ns[i].rows.length == 1 &amp;&amp; typeof(os[i]) != &quot;undefined&quot; &amp;&amp; os[i].rows.length == 1) {
                        				n[ns[i].rows[0]] = {
                        					text: n[ns[i].rows[0]],
                        					row: os[i].rows[0]
                        				};
                        				o[os[i].rows[0]] = {
                        					text: o[os[i].rows[0]],
                        					row: ns[i].rows[0]
                        				};
                        			}
                        		}
                        
                        		for (var i = 0; i &lt; n.length - 1; i++) {
                        			if (n[i].text != null &amp;&amp; n[i + 1].text == null &amp;&amp; n[i].row + 1 &lt; o.length &amp;&amp; o[n[i].row + 1].text == null &amp;&amp;
                        			n[i + 1] == o[n[i].row + 1]) {
                        				n[i + 1] = {
                        					text: n[i + 1],
                        					row: n[i].row + 1
                        				};
                        				o[n[i].row + 1] = {
                        					text: o[n[i].row + 1],
                        					row: i + 1
                        				};
                        			}
                        		}
                        
                        		for (var i = n.length - 1; i &gt; 0; i--) {
                        			if (n[i].text != null &amp;&amp; n[i - 1].text == null &amp;&amp; n[i].row &gt; 0 &amp;&amp; o[n[i].row - 1].text == null &amp;&amp;
                        			n[i - 1] == o[n[i].row - 1]) {
                        				n[i - 1] = {
                        					text: n[i - 1],
                        					row: n[i].row - 1
                        				};
                        				o[n[i].row - 1] = {
                        					text: o[n[i].row - 1],
                        					row: i - 1
                        				};
                        			}
                        		}
                        
                        		return {
                        			o: o,
                        			n: n
                        		};
                        	}
                        
                        	return function(o, n) {
                        		o = o.replace(/\s+$/, &#x27;&#x27;);
                        		n = n.replace(/\s+$/, &#x27;&#x27;);
                        		var out = diff(o == &quot;&quot; ? [] : o.split(/\s+/), n == &quot;&quot; ? [] : n.split(/\s+/));
                        
                        		var str = &quot;&quot;;
                        
                        		var oSpace = o.match(/\s+/g);
                        		if (oSpace == null) {
                        			oSpace = [&quot; &quot;];
                        		}
                        		else {
                        			oSpace.push(&quot; &quot;);
                        		}
                        		var nSpace = n.match(/\s+/g);
                        		if (nSpace == null) {
                        			nSpace = [&quot; &quot;];
                        		}
                        		else {
                        			nSpace.push(&quot; &quot;);
                        		}
                        
                        		if (out.n.length == 0) {
                        			for (var i = 0; i &lt; out.o.length; i++) {
                        				str += &#x27;&lt;del&gt;&#x27; + out.o[i] + oSpace[i] + &quot;&lt;/del&gt;&quot;;
                        			}
                        		}
                        		else {
                        			if (out.n[0].text == null) {
                        				for (n = 0; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
                        					str += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
                        				}
                        			}
                        
                        			for (var i = 0; i &lt; out.n.length; i++) {
                        				if (out.n[i].text == null) {
                        					str += &#x27;&lt;ins&gt;&#x27; + out.n[i] + nSpace[i] + &quot;&lt;/ins&gt;&quot;;
                        				}
                        				else {
                        					var pre = &quot;&quot;;
                        
                        					for (n = out.n[i].row + 1; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
                        						pre += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
                        					}
                        					str += &quot; &quot; + out.n[i].text + nSpace[i] + pre;
                        				}
                        			}
                        		}
                        
                        		return str;
                        	};
                        })();
                        
                        })(this);
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
